parameters:

- name: keyringPass
  type: string

- name: enableDotnet
  type: boolean
  default: false

- name: skipESRP
  type: boolean
  default: false # only to be used when testing the CI and we do not need a signed pkg

- name: signingSetupSteps
  type: stepList
  default: []

- name: isPR
  type: boolean

- name: packages
  type: object
  default: [
    {
      job: 'xamarin_ios_sign_notarize',
      name: 'Xamarin.iOS',
      pattern: 'xamarin.ios-*',
      conditionVariable: "INCLUDE_LEGACY_IOS",
    },
    {
      job: 'xamarin_mac_sing_notarie',
      name: 'Xamarin.Mac',
      pattern: 'xamarin.mac-*',
      conditionVariable: "INCLUDE_LEGACY_MAC",
    },
    {
      job: 'microsoft_ios_sign_notarize',
      name: 'Microsoft.iOS',
      pattern: 'Microsoft.iOS.Bundle*.pkg',
      conditionVariable: "INCLUDE_DOTNET_IOS",
    },
    {
      job: 'microsoft_tvos_sign_notarize',
      name: 'Microsoft.tvOS',
      pattern: 'Microsoft.tvOS.Bundle*.pkg',
      conditionVariable: "INCLUDE_DOTNET_TVOS",
    },
    {
      job: 'microsoft_mac_sign_notarize',
      name: 'Microsoft.macOS',
      pattern: 'Microsoft.macOS.Bundle*.pkg',
      conditionVariable: "INCLUDE_DOTNET_MACOS",
    },
    {
      job: 'microsoft_maccatalyst_sign_notarize',
      name: 'Microsoft.MacCatalyst',
      pattern: 'Microsoft.MacCatalyst.Bundle*.pkg',
      conditionVariable: "INCLUDE_DOTNET_MACCATALYST",
    },
  ]

jobs:
- job: configure
  displayName: 'Configure build'
  pool:
    vmImage: windows-latest

  variables:
    isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
    isScheduled: $[eq(variables['Build.Reason'], 'Schedule')]

  steps:
  - template: ../common/configure.yml

- ${{ each pkg in parameters.packages }}:
  - job: ${{ pkg.job }}
    dependsOn:
    - configure
    displayName: 'Sign & Notarize ${{ pkg.name }}'
    condition: ne(dependencies.configure.outputs['configure_platforms.${{ pkg.conditionVariable }}'],'')
    timeoutInMinutes: 1000
    pool:
      vmImage: internal-macos-11
    workspace:
      clean: all

    steps:
    - template: sign-and-notarized.yml
      parameters:
        isPR: ${{ parameters.isPR }}
        signingSetupSteps: ${{ parameters.signingSetupSteps }}
        keyringPass: ${{ parameters.keyringPass }}
        skipESRP: ${{ parameters.skipESRP }}
        packageName: ${{ pkg.name }}
        packagePattern: ${{ pkg.pattern }}

- ${{ if eq(parameters.enableDotnet, true) }}:
  - job: sign_notarize_dotnet
    dependsOn:
    - configure
    displayName: 'Sign & Notarize Dotnet'
    timeoutInMinutes: 1000
    pool:
      vmImage: internal-macos-11
    workspace:
      clean: all

    steps:
    - template: dotnet-signing.yml
      parameters:
        isPR: ${{ parameters.isPR }}

- job: funnel_job
  dependsOn:
  - configure
  - ${{ if eq(parameters.enableDotnet, true) }}:
    - sign_notarize_dotnet
  - ${{ each pkg in parameters.packages }}:
    - ${{ pkg.job }}
  displayName: 'Collect signed artifacts'
  condition: and(not(failed()), not(canceled())) # default is succeded(), but that fails if there are any skipped jobs, so change the condition to !failed && !cancelled
  timeoutInMinutes: 1000
  pool:
    vmImage: internal-macos-11
  workspace:
    clean: all
  variables:
    ${{ each pkg in parameters.packages }}:
      ${{ pkg.conditionVariable }}: $[ dependencies.configure.outputs['configure_platforms.${{ pkg.conditionVariable }}'] ]

  steps:
  - template: funnel.yml
    parameters:
      packages: ${{ parameters.packages }}


# This job uploads the pkgs generated by the build step in the azure blob storage. This has to be done in a different job
# because the azure blob storate tools DO NOT work on mac OS meaning that we need a bot running Windows. build uploads the contents
# to the pipeline artefacts and we download and upload to azure in this job.
- job: upload_azure_blob
  displayName: 'Upload packages to Azure & SBOM'
  timeoutInMinutes: 1000
  dependsOn:
  - funnel_job
  condition: and(not(failed()), not(canceled())) # default is succeded(), but that fails if there are any skipped jobs, so change the condition to !failed && !cancelled

  variables:
    Parameters.outputStorageUri: ''
    NUGETS_PUBLISHED: $[ dependencies.sign_notarize.outputs['nugetPublishing.NUGETS_PUBLISHED'] ]
    SKIP_NUGETS: $[ dependencies.configure.outputs['labels.skip-nugets'] ]

  pool:
    vmImage: 'windows-latest'
    workspace:
      clean: all
  steps:
  - template: upload-azure.yml
    parameters:
      enableDotnet: ${{ parameters.enableDotnet }}
      sbomFilter: '*.nupkg;*.pkg;*.msi'

# Job that runs on a vm that downloads the artifacts information and adds a github comment pointing to the results of the build.
- job: artifacts_github_comment
  displayName: 'Publish GitHub Comment - Artifacts'
  timeoutInMinutes: 1000
  dependsOn:
  - configure
  - upload_azure_blob
  condition: succeededOrFailed()
  variables:
    PR_ID: $[ dependencies.configure.outputs['labels.pr-number'] ]
    BUILD_PACKAGE: $[ dependencies.configure.outputs['labels.build-package'] ]
    TESTS_BOT: $[ stageDependencies.build_packages.build.outputs['build.TESTS_BOT'] ]  # we build in a diff bot than the ones used for the comments
    GIT_HASH: $[ stageDependencies.build_packages.build.outputs['fix_commit.GIT_HASH'] ]
  pool:
    vmImage: 'windows-latest'
    workspace:
      clean: all
  steps:
  - template: artifact-github-comment.yml
    parameters:
      isPR: ${{ parameters.isPR }}
