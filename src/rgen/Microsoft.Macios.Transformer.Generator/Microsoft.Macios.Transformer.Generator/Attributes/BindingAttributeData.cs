// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;

namespace Microsoft.Macios.Transformer.Generator.Attributes;

readonly struct BindingAttributeData {

	public static string Name = "BindingAttributeAttribute";
	public static string Source = @"// <auto-generated/>
using System;

namespace Microsoft.Macios.Transformer.Generator;

[AttributeUsage(AttributeTargets.Field)]
public class BindingAttributeAttribute(Type dataModelType, AttributeTargets target = AttributeTargets.All) : System.Attribute {

	public Type DataModelType { get; } = dataModelType;
	public AttributeTargets Target { get; } = target;

	public BindingAttributeAttribute (Type dataModelType) : this (dataModelType, AttributeTargets.All) { }
}
";

	public string DataModelType { get; } // is a type in the attribute, but we do not care for the transformation
	public AttributeTargets Target { get; }

	public BindingAttributeData (string dataModelType)
	{
		DataModelType = dataModelType;
	}

	public BindingAttributeData (string dataModelType, AttributeTargets targets)
	{
		DataModelType = dataModelType;
		Target = targets;
	}

	public static bool TryParse (AttributeData attributeData,
		[NotNullWhen (true)] out BindingAttributeData? data)
	{
		data = null;
		var count = attributeData.ConstructorArguments.Length;
		string baseType;
		var target = AttributeTargets.All;

		// custom marshal directive values

		switch (count) {
		case 1:
			baseType = ((INamedTypeSymbol) attributeData.ConstructorArguments [0].Value!).ToDisplayString ();
			break;
		case 2:
			baseType = ((INamedTypeSymbol) attributeData.ConstructorArguments [0].Value!).ToDisplayString ();
			target = (AttributeTargets) attributeData.ConstructorArguments [1].Value!;
			break;
		default:
			// 0 should not be an option..
			return false;
		}

		if (attributeData.NamedArguments.Length == 0) {
			data = new (baseType, target);
			return true;
		}

		foreach (var (argumentName, value) in attributeData.NamedArguments) {
			switch (argumentName) {
			case "Target":
				target = (AttributeTargets) value.Value!;
				break;
			default:
				data = null;
				return false;
			}
		}

		data = new (baseType, target);
		return true;
	}
}
