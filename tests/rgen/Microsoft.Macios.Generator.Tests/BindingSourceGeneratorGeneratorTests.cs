using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xamarin.Tests;
using Xamarin.Utils;
using Xunit;

namespace Microsoft.Macios.Generator.Tests;

// Unit test that ensures that all the generator attributes are correctly added in the compilation initialization
public class BindingSourceGeneratorGeneratorTests : BaseGeneratorTestClass {

	const string usingImportInput = @"
using System;
using Foundation;
using ObjCBindings;
namespace TestNamespace;

[BindingType (Name = ""AVAudioPCMBuffer"")]
public partial class AVAudioPcmBuffer : AVAudioBuffer {
}
";

	const string usingImportOutput = @"// <auto-generated>

#nullable enable

using Foundation;
using ObjCBindings;
using System;

namespace TestNamespace;

[Register(""AVAudioPCMBuffer"", true)]
public unsafe partial class AVAudioPcmBuffer
{
	[BindingImpl (BindingImplOptions.GeneratedCode | BindingImplOptions.Optimizable)]
	static readonly NativeHandle class_ptr = Class.GetHandle (""AVAudioPCMBuffer"");

	/// <summary>The Objective-C class handle for this class.</summary>
	/// <value>The pointer to the Objective-C class.</value>
	/// <remarks>
	///     Each managed class mirrors an unmanaged Objective-C class.
	///     This value contains the pointer to the Objective-C class.
	///     It is similar to calling the managed <see cref=""ObjCRuntime.Class.GetHandle(string)"" /> or the native <see href=""https://developer.apple.com/documentation/objectivec/1418952-objc_getclass"">objc_getClass</see> method with the type name.
	/// </remarks>
	public override NativeHandle ClassHandle { get { return class_ptr; } }

}
";

	[Theory]
	[AllSupportedPlatforms (usingImportInput, usingImportOutput)]
	public void CorrectUsingImports (ApplePlatform platform, string input, string expectedOutput)
	{
		// We need to create a compilation with the required source code.
		var (compilation, _) = CreateCompilation (nameof (CorrectUsingImports),
			platform, input);

		// Run generators and retrieve all results.
		var runResult = Driver.RunGenerators (compilation).GetRunResult ();
		Assert.Empty (runResult.Diagnostics);

		// ensure that we do have all the needed attributes present
		var generatedFile = runResult.GeneratedTrees.SingleOrDefault (t => t.FilePath.EndsWith ("AVAudioPcmBuffer.g.cs"));
		Assert.NotNull (generatedFile);
		Assert.Equal (expectedOutput, generatedFile.GetText ().ToString ());
	}

	const string nonPartialClass = @"
namespace TestNamespace;
public class NonPartialDeclaration {}
";
	const string partialClass = @"
namespace TestNamespace;
public partial class PartialDeclaration {}
";
	const string nonPartialInterface = @"
namespace TestNamespace;
public interface NonPartialInterface {}
";
	const string partialInterface = @"
namespace TestNamespace;
public partial interface PartialInterface {}
";
	const string enumType = @"
namespace TestNamespace;
public enum EnumType {
	First,
	Second,
	Last,
}";

	[Theory]
	[AllSupportedPlatforms (nonPartialClass, false)]
	[AllSupportedPlatforms (partialClass, true)]
	[AllSupportedPlatforms (nonPartialInterface, true)]
	[AllSupportedPlatforms (partialInterface, true)]
	[AllSupportedPlatforms (enumType, true)]
	public void IsValidNodeTest (ApplePlatform platform, string inputText, bool expectedResult)
	{
		var (_, syntaxTrees) = CreateCompilation (nameof (IsValidNodeTest), platform, inputText);
		Assert.Single (syntaxTrees);
		var declaration = syntaxTrees [0].GetRoot ()
			.DescendantNodes ()
			.OfType<BaseTypeDeclarationSyntax> ()
			.FirstOrDefault ();
		Assert.NotNull (declaration);
		Assert.Equal (expectedResult, BindingSourceGeneratorGenerator.IsValidNode (declaration));
	}
}
