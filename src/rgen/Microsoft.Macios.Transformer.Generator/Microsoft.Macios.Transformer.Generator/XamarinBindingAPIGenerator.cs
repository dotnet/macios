using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Macios.Generator;
using Microsoft.Macios.Transformer.Generator.Attributes;


namespace Microsoft.Macios.Transformer.Generator;

/// <summary>
/// Generator that will write the needed code to parse the old Xamarin API in the transformer. The
/// idea is that there is a lot of code that is needed by the tansformer that can be generated.
/// </summary>
[Generator]
public class XamarinBindingAPIGenerator : IIncrementalGenerator {
	const string Namespace = "Microsoft.Macios.Transformer.Generator";
	const string BindingFlagAttributeName = "BindingFlagAttribute";

	const string BindingAttributeAttributeSourceCode = @"// <auto-generated/>
using System;

namespace Microsoft.Macios.Transformer.Generator;

[AttributeUsage(AttributeTargets.Field)]
public class BindingAttributeAttribute(Type dataModelType, AttributeTargets target = AttributeTargets.All) : System.Attribute {
	public AttributeTargets Target { get; } = target;
	public Type DataModelType { get; } = dataModelType;
}
";

	public void Initialize (IncrementalGeneratorInitializationContext context)
	{
		// Add the marker attribute to the compilation.
		context.RegisterPostInitializationOutput (ctx => ctx.AddSource (
			"BindingFlagAttribute.g.cs",
			SourceText.From (BindingFlagData.Source, Encoding.UTF8)));

		context.RegisterPostInitializationOutput (ctx => ctx.AddSource (
			"BindingAttributeAttribute.g.cs",
			SourceText.From (BindingAttributeData.Source, Encoding.UTF8)));

		// Filter the [BindingFlagAttribute] annotate fields.
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider (
				(s, _) => s is FieldDeclarationSyntax,
				(ctx, _) => GetClassDeclarationForSourceGen (ctx))
			.Where (t => t.reportAttributeFound)
			.Select ((t, _) => t.Item1);

		// Generate the source code.
		context.RegisterSourceOutput (context.CompilationProvider.Combine (provider.Collect ()),
			((ctx, t) => GenerateCode (ctx, t.Left, t.Right)));
	}

	static (FieldDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen (
		GeneratorSyntaxContext context)
	{
		var declarationSyntax = Unsafe.As<FieldDeclarationSyntax> (context.Node);

		// Go through all attributes of the field
		foreach (AttributeListSyntax attributeListSyntax in declarationSyntax.AttributeLists)
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
				if (context.SemanticModel.GetSymbolInfo (attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
					continue; // if we can't get the symbol, ignore it

				string attributeName = attributeSymbol.ContainingType.ToDisplayString ();

				if (attributeName == $"{Namespace}.{BindingFlagAttributeName}")
					return (declarationSyntax, true);
			}

		return (declarationSyntax, false);
	}

	static string [] GetFlagsForTarget (Dictionary<string, (string AttributeName, AttributeTargets Targets)> flags,
		AttributeTargets targets)
		=> flags.Where (kv => kv.Value.Targets.HasFlag (targets))
			.Select (kv => kv.Key)
			.ToArray ();

	static void WriteFlagProperty (TabbedStringBuilder sb, string flagName)
	{
		// write the backing field
		sb.AppendLine ($"readonly bool _{flagName} = false;");
		using (var flagPropertyBlock = sb.CreateBlock ($"public bool {flagName}", block: true)) {
			flagPropertyBlock.AppendLine ($"get => _{flagName};");
			flagPropertyBlock.AppendLine ($"private init => _{flagName} = value;");
		}
	}

	static void WriteDataModelExtension (TabbedStringBuilder sb, string dataModel, string [] flags)
	{
		sb.Clear ();
		sb.AppendLine ("// <auto-generated/>");
		sb.AppendLine ("#nullable enable");
		sb.AppendLine ("");
		sb.AppendLine ("using System;");
		sb.AppendLine ("using Microsoft.CodeAnalysis;");
		sb.AppendLine ("using Microsoft.Macios.Transformer.Extensions;");
		sb.AppendLine ();
		sb.AppendLine ("namespace Microsoft.Macios.Generator.DataModel;");
		sb.AppendLine ();
		using (var modelBlock = sb.CreateBlock ($"readonly partial struct {dataModel}", block: true)) {
			// add all the properties that will allow us to get the flags make them public getter and private init
			// so that they can be set when we add the attr dict.
			foreach (var flag in flags) {
				modelBlock.AppendLine ();
				WriteFlagProperty (modelBlock, flag);
			}

			// property to store the dictionary
			modelBlock.AppendLine ();
			modelBlock.AppendLine ("readonly Dictionary<string, List<AttributeData>>? _attributesDictionary = null;");
			using (var dictionaryPropertyBlock = modelBlock.CreateBlock ("public Dictionary<string, List<AttributeData>>? AttributesDictionary", block: true)) {
				dictionaryPropertyBlock.AppendLine ("get => _attributesDictionary;");
				using (var initBlock = dictionaryPropertyBlock.CreateBlock ("private init", block: true)) {
					initBlock.AppendLine ("_attributesDictionary = value;");
					using (var ifBlock = initBlock.CreateBlock ("if (_attributesDictionary is not null)", block: true)) {
						foreach (var flag in flags) {
							ifBlock.AppendLine ($"_{flag} = _attributesDictionary.{flag} ();");
						}
					}
				}
			}
		}
	}

	static void GenerateModelExtension (TabbedStringBuilder sb, string dataModel,
		Dictionary<string, (string AttributeName, AttributeTargets Targets)> flags, AttributeTargets targets,
		SourceProductionContext context)
	{
		var methodFlags = GetFlagsForTarget (flags, targets);
		WriteDataModelExtension (sb, dataModel, methodFlags);
		context.AddSource ($"{dataModel}.Transformer.g.cs",
			SourceText.From (sb.ToString (), Encoding.UTF8));
	}

	static AttributeTargets GetTarget (ISymbol symbol)
	{
		var attrData = symbol.GetAttributes ();
		// loop over attrs, if we find the BindingFlagAttribute, return the target
		foreach (var attr in attrData) {
			if (attr.AttributeClass?.Name == BindingFlagAttributeName
				&& BindingFlagData.TryParse (attr, out var data)) {
				return data.Value.Target;
			}
		}
		return AttributeTargets.All;
	}

	void GenerateCode (SourceProductionContext context, Compilation compilation,
		ImmutableArray<FieldDeclarationSyntax> declarations)
	{
		// Go through all the fields that have the [BindingFlagAttribute] attribute, get the class name
		// and field name.
		var flags = new Dictionary<string, (string AttributeName, AttributeTargets Targets)> ();
		foreach (var fieldDeclarationSyntax in declarations) {
			// We need to get semantic model of the class to retrieve metadata.
			var semanticModel = compilation.GetSemanticModel (fieldDeclarationSyntax.SyntaxTree);

			foreach (var variableSyntax in fieldDeclarationSyntax.Declaration.Variables) {
				// get the symbol to retrieve the data
				if (semanticModel.GetDeclaredSymbol (variableSyntax) is not IFieldSymbol symbol)
					continue;
				var flagName = $"Has{symbol.Name.Replace ("Attribute", "Flag")}";
				var attrName = symbol.ToDisplayString ().Trim ();
				var target = GetTarget (symbol);
				flags [flagName] = (attrName, target);
			}
		}

		// all flags are collected, generate the code
		var sb = new TabbedStringBuilder (new ());
		sb.AppendLine ("// <auto-generated/>");
		sb.AppendLine ("#nullable enable");
		sb.AppendLine ("using System;");
		sb.AppendLine ("using System.Diagnostics.CodeAnalysis;");
		sb.AppendLine ("using Microsoft.CodeAnalysis;");
		sb.AppendLine ();
		sb.AppendLine ("namespace Microsoft.Macios.Transformer.Extensions;");
		sb.AppendLine ();
		using (var classBlock = sb.CreateBlock ("static class AttributeDataDictionaryExtension", block: true)) {
			// loop over the flags and generate a helper static method to retrieve it from a attribute data dict
			foreach (var (methodName, attributeName) in flags) {
				using (var methodBlock = classBlock.CreateBlock (
						   $"public static bool {methodName} (this Dictionary<string, List<AttributeData>> self)",
						   block: true)) {
					methodBlock.AppendLine ($"return self.ContainsKey ({attributeName.AttributeName});");
				}
				classBlock.AppendLine ();
			}
			// add a generic method that will allow use to retrieve an attribute type
			classBlock.AppendRaw (
@"public delegate bool TryParseDelegate<T> (AttributeData attributeData, [NotNullWhen (true)] out T? data) where T : struct;

public static T? GetAttribute<T> (this Dictionary<string, List<AttributeData>> self, string attrName, TryParseDelegate<T> tryParse) where T : struct 
{
	if (!self.TryGetValue (attrName, out var attrs))
		return null;

	foreach (var attr in attrs) {
		if (tryParse (attr, out var data))
			return data;
	}

	return null;
}
");
		}

		// Add the source code to the compilation.
		context.AddSource ("AttributeDataDictionaryExtensions.g.cs",
			SourceText.From (sb.ToString (), Encoding.UTF8));

		// generate the extra methods for the data model, group the fields by the model type based on the target
		var models = new (string Model, AttributeTargets Target) [] {
			("EnumMember", AttributeTargets.Field),
			("Parameter", AttributeTargets.Parameter),
			("Property", AttributeTargets.Property),
			("Method", AttributeTargets.Method),
			("Binding", AttributeTargets.Interface),
			("TypeInfo", AttributeTargets.Parameter)
		};
		foreach (var (model, target) in models) {
			GenerateModelExtension (sb, model, flags, target, context);
		}
	}
}
