using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Macios.Generator;


namespace Microsoft.Macios.Transformer.Generator;

/// <summary>
/// Generator that will write the needed code to parse the old Xamarin API in the transformer. The
/// idea is that there is a lot of code that is needed by the tansformer that can be generated.
/// </summary>
[Generator]
public class XamarinBindingAPIGenerator : IIncrementalGenerator {
	const string Namespace = "Microsoft.Macios.Transformer.Generator";
	const string AttributeName = "BindingFlagAttribute";

	const string AttributeSourceCode = @"// <auto-generated/>
using System;

namespace Microsoft.Macios.Transformer.Generator;

[AttributeUsage(AttributeTargets.Field)]
public class BindingFlagAttribute(AttributeTargets target = AttributeTargets.All) : System.Attribute {
	public AttributeTargets Target { get; } = target;
}
";

	public void Initialize (IncrementalGeneratorInitializationContext context)
	{
		// Add the marker attribute to the compilation.
		context.RegisterPostInitializationOutput (ctx => ctx.AddSource (
			"XamarinAPIAttributes.g.cs",
			SourceText.From (AttributeSourceCode, Encoding.UTF8)));

		// Filter the [BindingFlagAttribute] annotate fields.
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider (
				(s, _) => s is FieldDeclarationSyntax,
				(ctx, _) => GetClassDeclarationForSourceGen (ctx))
			.Where (t => t.reportAttributeFound)
			.Select ((t, _) => t.Item1);

		// Generate the source code.
		context.RegisterSourceOutput (context.CompilationProvider.Combine (provider.Collect ()),
			((ctx, t) => GenerateCode (ctx, t.Left, t.Right)));
	}

	static (FieldDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen (
		GeneratorSyntaxContext context)
	{
		var declarationSyntax = Unsafe.As<FieldDeclarationSyntax> (context.Node);

		// Go through all attributes of the field
		foreach (AttributeListSyntax attributeListSyntax in declarationSyntax.AttributeLists)
		foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
			if (context.SemanticModel.GetSymbolInfo (attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				continue; // if we can't get the symbol, ignore it

			string attributeName = attributeSymbol.ContainingType.ToDisplayString ();

			if (attributeName == $"{Namespace}.{AttributeName}")
				return (declarationSyntax, true);
		}

		return (declarationSyntax, false);
	}

	static string [] GetFlagsForTarget (Dictionary<string, (string AttributeName, AttributeTargets Targets)> flags,
		AttributeTargets targets)
		=> flags.Where (kv => kv.Value.Targets.HasFlag (targets))
			.Select (kv => kv.Key)
			.ToArray ();

	static void WriteDataModelExtension (TabbedStringBuilder sb, string dataModel, string [] flags)
	{
		sb.Clear ();
		sb.AppendLine ("// <auto-generated/>");
		sb.AppendLine ("#nullable enable");
		sb.AppendLine ("");
		sb.AppendLine ("using System;");
		sb.AppendLine ("using Microsoft.CodeAnalysis;");
		sb.AppendLine ("using Microsoft.Macios.Transformer.Extensions;");

		sb.AppendLine ("namespace Microsoft.Macios.Generator.DataModel;");
		sb.AppendLine ();
		using (var modelBlock = sb.CreateBlock ($"readonly partial struct {dataModel}", block: true)) {
			modelBlock.AppendLine ();
			// property to store the dictionary
			modelBlock.AppendLine ("Dictionary<string, List<AttributeData>>? AttributesDictionary { get; } = null;");

			// foreach flag add aproperty that will allow use to get it
			foreach (var flag in flags) {
				modelBlock.AppendLine ();
				modelBlock.AppendLine ($"public bool {flag} => AttributesDictionary?.{flag} () ?? false;");
			}
		}
	}

	static void GenerateModelExtension (TabbedStringBuilder sb, string dataModel,
		Dictionary<string, (string AttributeName, AttributeTargets Targets)> flags, AttributeTargets targets,
		SourceProductionContext context)
	{
		var methodFlags = GetFlagsForTarget (flags, targets);
		WriteDataModelExtension (sb, dataModel, methodFlags);
		context.AddSource ($"{dataModel}.Transformer.g.cs",
			SourceText.From (sb.ToString (), Encoding.UTF8));
	}

	static AttributeTargets GetTarget (ISymbol symbol)
	{
		var attrData = symbol.GetAttributes ();
		// loop over attrs, if we find the BindingFlagAttribute, return the target
		foreach (var attr in attrData) {
			if (attr.AttributeClass?.Name == AttributeName) {
				if (attr.ConstructorArguments.Length == 1) {
					return (AttributeTargets) attr.ConstructorArguments [0].Value!;
				}
			}
		}
		return AttributeTargets.All;
	}

	void GenerateCode (SourceProductionContext context, Compilation compilation,
		ImmutableArray<FieldDeclarationSyntax> declarations)
	{
		// Go through all the fields that have the [BindingFlagAttribute] attribute, get the class name
		// and field name.
		var flags = new Dictionary<string, (string AttributeName, AttributeTargets Targets)> ();
		foreach (var fieldDeclarationSyntax in declarations) {
			// We need to get semantic model of the class to retrieve metadata.
			var semanticModel = compilation.GetSemanticModel (fieldDeclarationSyntax.SyntaxTree);

			foreach (var variableSyntax in fieldDeclarationSyntax.Declaration.Variables) {
				// get the symbol to retrieve the data
				if (semanticModel.GetDeclaredSymbol (variableSyntax) is not IFieldSymbol symbol)
					continue;
				var flagName = $"Has{symbol.Name.Replace ("Attribute", "Flag")}";
				var attrName = symbol.ToDisplayString ().Trim ();
				var target = GetTarget (symbol);
				flags [flagName] = (attrName, target);
			}
		}

		// all flags are collected, generate the code
		var sb = new TabbedStringBuilder (new());
		sb.AppendLine ("// <auto-generated/>");
		sb.AppendLine ("using System;");
		sb.AppendLine ("using Microsoft.CodeAnalysis;");

		sb.AppendLine ("namespace Microsoft.Macios.Transformer.Extensions;");

		using (var classBlock = sb.CreateBlock ("static class AttributeDataDictionaryExtension", block: true)) {
			// loop over the flags and generate a helper static method to retrieve it from a attribute data dict
			foreach (var (methodName, attributeName) in flags) {
				using (var methodBlock = classBlock.CreateBlock (
					       $"public static bool {methodName} (this Dictionary<string, List<AttributeData>> self)",
					       block: true)) {
					methodBlock.AppendLine ($"return self.ContainsKey ({attributeName.AttributeName});");
				}

				classBlock.AppendLine ();
			}
		}

		// Add the source code to the compilation.
		context.AddSource ("AttributeDataDictionaryExtensions.g.cs",
			SourceText.From (sb.ToString (), Encoding.UTF8));

		// generate the extra methods for the data model, group the fields by the model type based on the target
		var models = new (string Model, AttributeTargets Target) [] {
			("EnumMember", AttributeTargets.Field),
			("Parameter", AttributeTargets.Parameter),
			("Property", AttributeTargets.Property),
			("Method", AttributeTargets.Method),
			("Binding", AttributeTargets.Interface),
			("TypeInfo", AttributeTargets.Parameter)
		};
		foreach (var (model, target) in models) {
			GenerateModelExtension (sb, model, flags, target, context);
		}
	}
}
