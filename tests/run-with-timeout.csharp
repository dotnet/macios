#!/usr/bin/env /Library/Frameworks/Mono.framework/Commands/csharp -s

// arguments are: <platform> <outputPath>

using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;

var args = Environment.GetCommandLineArgs ();
var initialArgumentCount = 3;
if (args.Length <= initialArgumentCount + 1 /* 3 default arguments (executable + script + -s) */) {
	// first arg is "/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/4.5/csharp.exe"
	// second arg the script itself
	// third argument is -s
	// then comes the ones we care about
	Console.WriteLine ($"Need two arguments (the timeout + the command to launch), got {args.Length - initialArgumentCount} argument(s)");
	Environment.Exit (1);
	return;
}

var launchTimeout = TimeSpan.FromSeconds (10); // must launch within a few seconds.
var argIndex = initialArgumentCount;
var executionTimeout = TimeSpan.FromSeconds (int.Parse (args [argIndex++]));
var commands = args.Skip (argIndex).ToArray ();

var pid = Process.GetCurrentProcess ().Id;
var maxLaunchAttempts = 10;
var exitCode = -1;

var logOutput = new List<string> ();
var log = new Process ();
Thread stdoutThread, stderrThread;
{
	// Capture the system log
	log.StartInfo.FileName = "log";
	log.StartInfo.Arguments = "stream";
	log.StartInfo.UseShellExecute = false;
	log.StartInfo.RedirectStandardOutput = true;
	log.StartInfo.RedirectStandardError = true;
	log.StartInfo.StandardOutputEncoding = Encoding.UTF8;
	log.StartInfo.StandardErrorEncoding = Encoding.UTF8;

	var StartOutputThread = new Func<StreamReader, string, Thread> ((StreamReader reader, string thread_name) =>
	{
		var thread = new Thread (() => {
			try {
				while (reader.ReadLine () is string line) {
					lock (logOutput)
						logOutput.Add (line);
				}
			} finally {
				// The Process instance doesn't dispose these streams, which means we need to do it,
				// otherwise we can run out of file descriptors while waiting for the GC to kick in.
				// Ref: https://bugzilla.xamarin.com/show_bug.cgi?id=43462
				reader.Dispose ();
			}
		}) {
			IsBackground = true,
			Name = thread_name,
		};
		thread.Start ();
		return thread;
	});

	log.Start ();
	var pid = log.Id;
	stdoutThread = StartOutputThread (log.StandardOutput, $"StandardOutput reader for {log.StartInfo.FileName} (PID: {pid})");
	stderrThread = StartOutputThread (log.StandardError, $"StandardError reader for {log.StartInfo.FileName} (PID: {pid})");
}

for (var attempt = 0; attempt < maxLaunchAttempts; attempt++) {
	var launchTimeoutFile = Path.GetFullPath ($"launch-timeout-sentinel-{pid}-{attempt}.txt");
	var launchTimedOut = new ManualResetEvent (false);
	var p = new Process ();

	var launchTimer = new Thread (() => {
		if (p.WaitForExit ((int) launchTimeout.TotalMilliseconds)) {
			Console.WriteLine ($"App finished before launch timeout triggered.");
		} else if (!File.Exists (launchTimeoutFile)) {
			Console.WriteLine ($"Launch timed out after {launchTimeout.TotalSeconds} seconds.");
			launchTimedOut.Set ();
			p.Kill ();
		}
	}) {
		IsBackground = true,
	};

	try {
		p.StartInfo.FileName = commands [0];
		p.StartInfo.Arguments = string.Join (" ", commands.Skip (1));
		p.StartInfo.UseShellExecute = false;
		p.StartInfo.EnvironmentVariables ["LAUNCH_SENTINEL_FILE"] = launchTimeoutFile;

		Console.WriteLine ($"Launching (attempt #{attempt + 1}):");
		Console.WriteLine ($"    {p.StartInfo.FileName} {p.StartInfo.Arguments}");

		p.Start ();

		launchTimer.Start ();

		if (!p.WaitForExit ((int) executionTimeout.TotalMilliseconds)) {
			Console.WriteLine ($"Execution timed out after {executionTimeout.TotalSeconds} seconds.");
			p.Kill ();
			p.WaitForExit ();
		}

		launchTimer.Join ();

		exitCode = p.ExitCode;

		if (launchTimedOut.WaitOne (0)) {
			Console.WriteLine ($"Launching again since the launch timeout triggered.");
			continue;
		}
		Console.WriteLine ($"Execution completed with exit code {exitCode}");
	} finally {
		File.Delete (launchTimeoutFile);
		p.Dispose ();
	}
	break;
}

log.Kill ();
stdoutThread.Join (TimeSpan.FromSeconds (3));
stderrThread.Join (TimeSpan.FromSeconds (3));

if (exitCode != 0) {
	Console.WriteLine ("Output from 'log stream':");
	foreach (var line in logOutput)
		Console.WriteLine ($"    {line}");
}

Environment.Exit (exitCode);
